/**
 * Neuron Type Search and Autocomplete
 * Provides client-side search functionality for neuron types
 *
 * This file is generated at build time.
 * Do not edit manually - it will be overwritten during the build process.
 *
 * Generated on: {{ generation_timestamp }}
 * Total neuron types: {{ neuron_types|length }}
 */

class NeuronSearch {
  constructor(inputId = "menulines") {
    this.inputElement = document.getElementById(inputId);
    this.neuronTypes = [];
    this.neuronData = [];
    this.filteredTypes = [];
    this.currentIndex = -1;
    this.isDropdownVisible = false;
    this.clickingDropdown = false;
    this.isReady = false;
    this.dataSource = null;

    // Detect if we're on a neuron page (inside types folder) based on current path
    this.isNeuronPage = this.detectNeuronPageContext();

    // Set path prefix for loading resources
    this.pathPrefix = this.isNeuronPage ? '../' : '';

    // Set URL prefix for neuron pages
    this.urlPrefix = this.isNeuronPage ? '' : 'types/';

    // Create autocomplete dropdown
    this.dropdown = this.createDropdown();
  }

  /**
   * Detect if we're currently on a neuron page (inside types folder)
   */
  detectNeuronPageContext() {
    const pathname = window.location.pathname;

    // Check if we're in a types subdirectory
    if (pathname.includes('/types/')) {
      return true;
    }

    // Check if current page is an HTML file that's not index.html, types.html, or help.html
    // This catches cases where neuron pages might be in the root but are individual neuron files
    const filename = pathname.split('/').pop();
    if (filename && filename.endsWith('.html') &&
        !['index.html', 'types.html', 'help.html'].includes(filename)) {
      return true;
    }

    return false;
  }

  /**
   * Initialize the search functionality
   */
  async init() {
    if (!this.inputElement) {
      console.warn("Search input element not found");
      return;
    }

    // Load neuron data
    const data = await this.loadNeuronData();
    this.neuronTypes = data.names || [];
    this.neuronData = data.neurons || [];
    this.isReady = true;

    // Set up event listeners
    this.setupEventListeners();

    console.log(
      `Loaded ${this.neuronTypes.length} neuron types (source: ${this.dataSource})`
    );
  }

  /**
   * Load neuron data with fallback mechanism
   * Try JSON first, fall back to JS file if that fails
   */
  async loadNeuronData() {
    // Try loading from JSON first
    try {
      const data = await this.loadFromJSON();
      this.dataSource = 'json';
      return data;
    } catch (jsonError) {
      console.warn('JSON loading failed, trying fallback JS file:', jsonError.message);

      // Fall back to loading JS file
      try {
        const data = await this.loadFromJSFallback();
        this.dataSource = 'js-fallback';
        return data;
      } catch (jsError) {
        console.error('Both JSON and JS fallback loading failed:', jsError.message);
        this.dataSource = 'none';

        // Return empty data as last resort
        return {
          types: [],
          details: [],
          metadata: { error: true }
        };
      }
    }
  }

  /**
   * Load data from JSON file (preferred method)
   */
  async loadFromJSON() {
    const url = `${this.pathPrefix}data/neurons.json`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    return {
      names: data.names || [],
      neurons: data.neurons || []
    };
  }

  /**
   * Load data from JS fallback file (for CORS-restricted environments)
   * Uses dynamic script loading which bypasses CORS
   */
  loadFromJSFallback() {
    return new Promise((resolve, reject) => {
      // Set up callback for the JS file to call
      window.neuronDataCallback = (data) => {
        delete window.neuronDataCallback; // Clean up
        resolve({
          names: data.names || [],
          neurons: data.neurons || []
        });
      };

      // Create script element
      const script = document.createElement('script');
      script.src = `${this.pathPrefix}data/neurons.js`;
      script.async = true;

      // Handle successful load
      script.onload = () => {
        // If data was already set globally instead of using callback
        if (window.NEURON_DATA_FALLBACK && window.neuronDataCallback) {
          const data = window.NEURON_DATA_FALLBACK;
          delete window.NEURON_DATA_FALLBACK; // Clean up
          delete window.neuronDataCallback;
          resolve({
            names: data.names || [],
            neurons: data.neurons || []
          });
        }
        // If callback hasn't been called within 100ms, something went wrong
        setTimeout(() => {
          if (window.neuronDataCallback) {
            delete window.neuronDataCallback;
            reject(new Error('JS fallback loaded but callback not invoked'));
          }
        }, 100);
      };

      // Handle load error
      script.onerror = () => {
        delete window.neuronDataCallback;
        reject(new Error('Failed to load neurons.js fallback file'));
      };

      // Add script to document
      document.head.appendChild(script);

      // Timeout after 5 seconds
      setTimeout(() => {
        if (window.neuronDataCallback) {
          delete window.neuronDataCallback;
          script.remove();
          reject(new Error('Timeout loading neuron data fallback'));
        }
      }, 5000);
    });
  }

  /**
   * Create the autocomplete dropdown element
   */
  createDropdown() {
    const dropdown = document.createElement("div");
    dropdown.className = "neuron-search-dropdown";
    dropdown.style.cssText = `
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        `;

    // Insert dropdown after the input element
    const parent = this.inputElement.parentNode;
    parent.style.position = "relative";
    parent.appendChild(dropdown);

    return dropdown;
  }

  /**
   * Set up event listeners for the search functionality
   */
  setupEventListeners() {
    // Input event for real-time search
    this.inputElement.addEventListener("input", (e) => {
      this.handleInput(e.target.value);
    });

    // Keyboard navigation
    this.inputElement.addEventListener("keydown", (e) => {
      this.handleKeyDown(e);
    });

    // Focus and blur events
    this.inputElement.addEventListener("focus", () => {
      if (this.inputElement.value.trim()) {
        this.showDropdown();
      }
    });

    this.inputElement.addEventListener("blur", () => {
      // Delay hiding to allow click on dropdown items
      setTimeout(() => {
        // Only hide if no dropdown item is being clicked
        if (!this.clickingDropdown) {
          this.hideDropdown();
        }
      }, 300);
    });

    // Click outside to close dropdown
    document.addEventListener("click", (e) => {
      if (
        !this.inputElement.contains(e.target) &&
        !this.dropdown.contains(e.target)
      ) {
        this.hideDropdown();
      }
    });
  }

  /**
   * Handle input changes
   */
  handleInput(value) {
    const query = value.trim().toLowerCase();

    if (query.length === 0) {
      this.hideDropdown();
      return;
    }

    // Filter neuron types by name, synonyms, and flywire types
    this.filteredTypes = this.neuronTypes.filter((type) => {
      const typeLower = type.toLowerCase();

      // Search in neuron name
      if (typeLower.includes(query)) {
        return true;
      }

      // Search in types (synonyms and flywire) from detailed data
      const neuronEntry = this.neuronData.find(entry => entry.name === type);
      if (neuronEntry && neuronEntry.types) {
        // Search in synonyms
        if (neuronEntry.types.synonyms && Array.isArray(neuronEntry.types.synonyms)) {
          for (const synonym of neuronEntry.types.synonyms) {
            const synonymLower = synonym.toLowerCase();
            // Search in full synonym text
            if (synonymLower.includes(query)) {
              return true;
            }
            // Also search in just the part after colon (the actual name)
            const colonIndex = synonymLower.indexOf(':');
            if (colonIndex !== -1) {
              const nameAfterColon = synonymLower.substring(colonIndex + 1).trim();
              if (nameAfterColon.includes(query)) {
                return true;
              }
            }
          }
        }

        // Search in flywire types
        if (neuronEntry.types.flywire && Array.isArray(neuronEntry.types.flywire)) {
          for (const flywireType of neuronEntry.types.flywire) {
            if (flywireType.toLowerCase().includes(query)) {
              return true;
            }
          }
        }
      }

      return false;
    });

    // Sort by relevance (exact matches first, then starts with, then contains)
    this.filteredTypes.sort((a, b) => {
      const aLower = a.toLowerCase();
      const bLower = b.toLowerCase();

      // Exact match comes first
      if (aLower === query) return -1;
      if (bLower === query) return 1;

      // Starts with query comes next
      if (aLower.startsWith(query) && !bLower.startsWith(query)) return -1;
      if (bLower.startsWith(query) && !aLower.startsWith(query)) return 1;

      // Otherwise alphabetical order
      return a.localeCompare(b);
    });

    // Limit results to prevent performance issues
    this.filteredTypes = this.filteredTypes.slice(0, 10);

    this.currentIndex = -1;
    this.updateDropdown();
    this.showDropdown();
  }

  /**
   * Handle keyboard navigation
   */
  handleKeyDown(e) {
    if (!this.isDropdownVisible) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        this.currentIndex = Math.min(
          this.currentIndex + 1,
          this.filteredTypes.length - 1,
        );
        this.updateHighlight();
        break;

      case "ArrowUp":
        e.preventDefault();
        this.currentIndex = Math.max(this.currentIndex - 1, -1);
        this.updateHighlight();
        break;

      case "Enter":
        e.preventDefault();
        if (this.currentIndex >= 0) {
          this.selectNeuronType(this.filteredTypes[this.currentIndex]);
        } else if (this.filteredTypes.length > 0) {
          this.selectNeuronType(this.filteredTypes[0]);
        }
        break;

      case "Escape":
        this.hideDropdown();
        this.inputElement.blur();
        break;
    }
  }

  /**
   * Update the dropdown content
   */
  updateDropdown() {
    this.dropdown.innerHTML = "";

    if (this.filteredTypes.length === 0) {
      const noResults = document.createElement("div");
      noResults.className = "neuron-search-no-results";
      noResults.textContent = "No matching neuron types found";
      noResults.style.cssText = `
                padding: 8px 12px;
                color: #666;
                font-style: italic;
            `;
      this.dropdown.appendChild(noResults);
      return;
    }

    this.filteredTypes.forEach((type, index) => {
      const item = document.createElement("div");
      item.className = "neuron-search-item";
      item.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
                transition: background-color 0.2s;
            `;

      // Create content with neuron name and clickable available sides
      const neuronEntry = this.neuronData.find(entry => entry.name === type);

      // Create neuron name element
      const nameSpan = document.createElement('span');
      nameSpan.className = 'neuron-name';
      nameSpan.style.cssText = `
        color: inherit;
        cursor: pointer;
      `;

      // Highlight matching text in neuron name
      const query = this.inputElement.value.trim().toLowerCase();
      if (query) {
        const regex = new RegExp(`(${this.escapeRegExp(query)})`, "gi");
        nameSpan.innerHTML = type.replace(regex, "<strong>$1</strong>");
      } else {
        nameSpan.textContent = type;
      }

      item.appendChild(nameSpan);

      // Add available sides as clickable links
      if (neuronEntry && neuronEntry.urls) {
        const sides = [];
        if (neuronEntry.urls.right) sides.push({ label: 'R', side: 'right' });
        if (neuronEntry.urls.middle) sides.push({ label: 'M', side: 'middle' });
        if (neuronEntry.urls.left) sides.push({ label: 'L', side: 'left' });
        if (neuronEntry.urls.combined && sides.length === 0) sides.push({ label: 'Combined', side: 'combined' });

        if (sides.length > 0) {
          const sidesContainer = document.createElement('span');
          sidesContainer.textContent = ' (';
          sidesContainer.style.color = '#666';

          sides.forEach((sideInfo, index) => {
            if (index > 0) {
              const separator = document.createElement('span');
              separator.textContent = ', ';
              separator.style.color = '#666';
              sidesContainer.appendChild(separator);
            }

            const sideLink = document.createElement('a');
            sideLink.textContent = sideInfo.label;
            sideLink.href = '#';
            sideLink.className = 'side-link';
            sideLink.style.cssText = `
              color: #0066cc;
              text-decoration: none;
              cursor: pointer;
              font-size: 0.9em;
            `;

            // Hover effect
            sideLink.addEventListener('mouseenter', () => {
              sideLink.style.textDecoration = 'underline';
            });
            sideLink.addEventListener('mouseleave', () => {
              sideLink.style.textDecoration = 'none';
            });

            // Click handler for side-specific navigation
            sideLink.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.navigateToSomaSide(type, sideInfo.side);
            });

            sidesContainer.appendChild(sideLink);
          });

          const closeParen = document.createElement('span');
          closeParen.textContent = ')';
          closeParen.style.color = '#666';
          sidesContainer.appendChild(closeParen);

          item.appendChild(sidesContainer);
        }
      }

      // Mouse events for click handling
      item.addEventListener("mousedown", (e) => {
        // Only prevent default if not clicking on a side link
        if (!e.target.classList.contains('side-link')) {
          e.preventDefault(); // Prevent input blur
          this.clickingDropdown = true;
        }
      });

      // Main item click handler (neuron name goes to primary page, side links handled separately)
      item.addEventListener("click", (e) => {
        if (!e.target.classList.contains('side-link')) {
          e.preventDefault();
          e.stopPropagation();
          this.selectNeuronType(type);
          this.clickingDropdown = false;
        }
      });

      // Hover handler
      item.addEventListener("mouseenter", () => {
        this.currentIndex = index;
        this.updateHighlight();
      });

      this.dropdown.appendChild(item);
    });
  }

  /**
   * Escape regex special characters
   */
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  /**
   * Update visual highlighting of selected item
   */
  updateHighlight() {
    const items = this.dropdown.querySelectorAll(".neuron-search-item");
    items.forEach((item, index) => {
      if (index === this.currentIndex) {
        item.style.backgroundColor = "#f0f8ff";
        item.style.color = "#0066cc";
      } else {
        item.style.backgroundColor = "";
        item.style.color = "";
      }
    });
  }

  /**
   * Select a neuron type and navigate to its page
   */
  selectNeuronType(neuronType) {
    this.inputElement.value = neuronType;
    this.hideDropdown();

    // Navigate to the neuron type page
    this.navigateToNeuronType(neuronType);
  }

  /**
   * Navigate to the selected neuron type page
   */
  navigateToNeuronType(neuronType) {
    // Find the neuron data entry for this type
    const neuronEntry = this.neuronData.find(entry => entry.name === neuronType);

    if (neuronEntry && neuronEntry.urls) {
      // Get primary URL (prefer combined, then left, then right, then middle)
      let targetUrl = neuronEntry.urls.combined ||
                      neuronEntry.urls.left ||
                      neuronEntry.urls.right ||
                      neuronEntry.urls.middle ||
                      `${neuronType}.html`;

      // Add URL prefix (types/ for non-neuron pages, empty for neuron pages)
      targetUrl = this.urlPrefix + targetUrl;

      window.location.href = targetUrl;
    } else {
      // Fallback to the old detection method
      this.navigateToNeuronTypeWithDetection(neuronType);
    }
  }

  /**
   * Fallback navigation method that tries to detect the correct file
   */
  async navigateToNeuronTypeWithDetection(neuronType) {
    // Adjust path prefix based on current page location
    const pathPrefix = this.isNeuronPage ? '' : 'types/';

    // Check which file naming convention exists for this neuron type
    const possibleFilenames = [
      `types/${neuronType}.html`,
      `types/${neuronType.toLowerCase()}.html`,
      `types/${neuronType}_combined.html`,
      `types/${neuronType.toLowerCase()}_combined.html`,
      `types/${neuronType}_both.html`,
      `types/${neuronType.toLowerCase()}_both.html`,
      `types/${neuronType}_all.html`,
      `types/${neuronType.toLowerCase()}_all.html`,
    ];

    // Try to find which file exists
    let targetFile = possibleFilenames[0]; // default fallback

    for (const filename of possibleFilenames) {
      try {
        const response = await fetch(filename, { method: "HEAD" });
        if (response.ok) {
          targetFile = filename;
          break;
        }
      } catch (e) {
        // Continue trying other filenames
        continue;
      }
    }

    // Navigate to the found or fallback filename
    window.location.href = targetFile;
  }

  /**
   * Get available URLs for a specific neuron type
   */
  getNeuronUrls(neuronType) {
    const neuronEntry = this.neuronData.find(entry => entry.name === neuronType);
    return neuronEntry ? neuronEntry.urls : {};
  }

  /**
   * Navigate to a specific soma side page for a neuron type
   */
  navigateToSomaSide(neuronType, side) {
    const neuronEntry = this.neuronData.find(entry => entry.name === neuronType);

    if (neuronEntry && neuronEntry.urls && neuronEntry.urls[side]) {
      // Close dropdown and update input
      this.inputElement.value = neuronType;
      this.hideDropdown();

      // Add URL prefix (types/ for non-neuron pages, empty for neuron pages)
      let targetUrl = this.urlPrefix + neuronEntry.urls[side];

      // Navigate to the specific side page
      window.location.href = targetUrl;
    } else {
      // Fallback to primary URL
      this.navigateToNeuronType(neuronType);
    }
  }

  /**
   * Show the dropdown
   */
  showDropdown() {
    if (
      this.filteredTypes.length > 0 ||
      this.dropdown.querySelector(".neuron-search-no-results")
    ) {
      this.dropdown.style.display = "block";
      this.isDropdownVisible = true;
    }
  }

  /**
   * Hide the dropdown
   */
  hideDropdown() {
    this.dropdown.style.display = "none";
    this.isDropdownVisible = false;
    this.currentIndex = -1;
    this.clickingDropdown = false;
  }

  /**
   * Public method to get neuron types count
   */
  getNeuronTypesCount() {
    return this.neuronTypes.length;
  }
}

// Initialize the search functionality when the DOM is loaded
document.addEventListener("DOMContentLoaded", async () => {
  // Initialize neuron search
  if (document.getElementById('menulines')) {
    window.neuronSearch = new NeuronSearch("menulines");
    await window.neuronSearch.init();
  }
});

// Export for module use if needed
if (typeof module !== "undefined" && module.exports) {
  module.exports = NeuronSearch;
}
