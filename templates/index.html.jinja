{% extends "base.html.jinja" %}

{% block title %}{{ config.html.title_prefix }} – Cell Type Explorer – Home{% endblock %}

{% block header %}
{% include "sections/header.html.jinja" %}
{% endblock %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-xs-12">
            <div class="landing-page">
                <div class="hero-section">
                    <h1>{{ config.html.title_prefix }} – Cell Type Explorer</h1>
                    <p class="lead">Comprehensive neuron type catalog for the {{ config.neuprint.dataset}} dataset</p>

                    <div class="stats-overview">
                        <div class="stat-item">
                            <span class="stat-number">{{ '{:,}'.format(total_types) }}</span>
                            <span class="stat-label">Neuron Types</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">{{ '{:,}'.format(total_neurons) if total_neurons is defined and total_neurons > 0 else 'N/A' }}</span>
                            <span class="stat-label">Neurons</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">{{ '{:,}'.format(total_synapses) if total_synapses is defined and total_synapses > 0 else 'N/A' }}</span>
                            <span class="stat-label">Synapses</span>
                        </div>
                    </div>

                    <div class="action-buttons">
                        <a href="types.html" class="btn btn-secondary btn-large">
                            Browse All Types
                        </a>
                        <a href="help.html" class="btn btn-secondary btn-large">
                            Learn How to Use
                        </a>
                    </div>
                </div>

                <div class="quick-search-section">
                    <h2>Quick Search</h2>
                    <p>Start typing a neuron type name to quickly navigate:</p>
                    <form class="search-form-large">
                        <div class="quick-search-container">
                            <input id="landing-search" type="text" placeholder="Search for neuron types (e.g., T4, Mi1, LC10)..." />
                        </div>
                    </form>
                </div>

                <div class="dataset-info">
                    <h2>About This Dataset</h2>
                    <p>
                        This Cell Type Catalog presents a comprehensive view of neuron types from the
                        <strong>{{ config.neuprint.dataset }}</strong> connectome dataset.
                        For each neuron type in the dataset, we show morphological information, connectivity patterns,
                        and spatial distributions.
                    </p>
                    <p>
                        Data represents a temporal snapshot generated on {{ generation_time.strftime('%Y-%m-%d %H:%M') }} from <a href="https://{{- config.neuprint.server -}}/?dataset={{- config.neuprint.dataset -}}" target="_blank">neuPrint</a>.</p>
                    <p class="pm-text-light"> At the time, the {{ config.neuprint.dataset }} dataset at {{ config.neuprint.server }} was at version {{ metadata.uuid }} and had the last update at {{ metadata.lastDatabaseEdit }}.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
{#  Landing page specific styles #}
.landing-page {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem 1rem;
}

.hero-section {
    text-align: center;
    padding: 3rem 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 8px;
    margin-bottom: 3rem;
}

.hero-section h1 {
    font-size: 3rem;
    margin-bottom: 1rem;
    font-weight: 300;
}

.hero-section .lead {
    font-size: 1.25rem;
    margin-bottom: 2rem;
    opacity: 0.9;
}

.stats-overview {
    margin: 2rem 0;
}

.stat-item {
    display: inline-block;
    margin: 0 2rem;
}

.stat-number {
    display: block;
    font-size: 2.5rem;
    font-weight: bold;
    line-height: 1;
}

.stat-label {
    display: block;
    font-size: 0.9rem;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.action-buttons {
    margin-top: 2rem;
}

.btn {
    display: inline-block;
    padding: 0.75rem 2rem;
    margin: 0 0.5rem;
    border-radius: 4px;
    text-decoration: none;
    font-weight: 500;
    transition: all 0.3s ease;
    border: none;
    cursor: pointer;
}

.btn-large {
    padding: 1rem 2.5rem;
    font-size: 1.1rem;
}

.btn-primary {
    background-color: #28a745;
    color: white;
}

.btn-primary:hover {
    background-color: #218838;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
}

.btn-secondary {
    background-color: transparent;
    color: white;
    border: 2px solid white;
}

.btn-secondary:hover {
    background-color: white;
    color: #667eea;
    transform: translateY(-2px);
}

.feature-highlights {
    margin: 4rem 0;
}

.feature-card {
    background: #f8f9fa;
    padding: 2rem;
    border-radius: 8px;
    height: 100%;
    text-align: center;
    transition: transform 0.3s ease;
}

.feature-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
}

.feature-card h3 {
    color: #333;
    margin-bottom: 1rem;
}

.feature-card p {
    color: #666;
    line-height: 1.6;
}

.quick-search-section {
    background: #f8f9fa;
    padding: 3rem;
    border-radius: 8px;
    text-align: center;
    margin: 3rem 0;
}

.quick-search-section h2 {
    margin-bottom: 1rem;
    color: #333;
}

.search-form-large {
    max-width: 600px;
    margin: 0 auto;
}

.quick-search-container {
    position: relative;
}

.search-form-large input {
    width: 100%;
    padding: 1rem;
    font-size: 1.1rem;
    border: 2px solid #dee2e6;
    border-radius: 6px;
    transition: border-color 0.3s ease;
}

.search-form-large input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.dataset-info {
    background: white;
    padding: 3rem;
    border-radius: 8px;
    border: 1px solid #e9ecef;
    margin: 3rem 0;
}

.dataset-info h2 {
    color: #333;
    margin-bottom: 1.5rem;
}

.dataset-info p {
    color: #666;
    line-height: 1.7;
    margin-bottom: 1rem;
}

.dataset-info a {
    color: #667eea;
    text-decoration: none;
}

.dataset-info a:hover {
    text-decoration: underline;
}

@media (max-width: 768px) {
    .hero-section {
        padding: 2rem 1rem;
    }

    .hero-section h1 {
        font-size: 2rem;
    }

    .stat-item {
        display: block;
        margin: 1rem 0;
    }

    .btn {
        display: block;
        margin: 0.5rem 0;
    }

    .feature-card {
        margin-bottom: 2rem;
    }

    .quick-search-section,
    .dataset-info {
        padding: 2rem 1rem;
    }
}
</style>

<script>
{# Quick search functionality that mirrors the header search behavior #}
document.addEventListener('DOMContentLoaded', async function() {
    const landingSearch = document.getElementById('landing-search');

    if (!landingSearch) return;

    {# Wait for the main neuron search to load data, then initialize quick search #}
    if (window.neuronSearch) {
        {# Use data from main search if already loaded #}
        await window.neuronSearch.init();
        const quickSearch = new QuickNeuronSearch('landing-search');
        await quickSearch.init();
    } else {
        {# Initialize quick search independently #}
        const quickSearch = new QuickNeuronSearch('landing-search');
        await quickSearch.init();
    }
});

class QuickNeuronSearch {
    constructor(inputId) {
        this.inputElement = document.getElementById(inputId);
        this.neuronTypes = [];
        this.neuronData = [];
        this.filteredTypes = [];
        this.currentIndex = -1;
        this.isDropdownVisible = false;
        this.clickingDropdown = false;
        this.isReady = false;

        {# Create autocomplete dropdown #}
        this.dropdown = this.createDropdown();
    }

    async init() {
        if (!this.inputElement) {
            return;
        }

        {# Load neuron data #}
        const data = await this.loadNeuronData();
        this.neuronTypes = data.names || [];
        this.neuronData = data.neurons || [];
        this.isReady = true;

        this.setupEventListeners();
    }

    async loadNeuronData() {
        {# Try to use data from main neuron search if available #}
        if (window.neuronSearch && window.neuronSearch.isReady) {
            return {
                names: window.neuronSearch.neuronTypes,
                neurons: window.neuronSearch.neuronData
            };
        }

        {# Otherwise load independently #}
        try {
            const response = await fetch('data/neurons.json');
            if (!response.ok) throw new Error('JSON load failed');
            const data = await response.json();
            return {
                names: data.names || [],
                neurons: data.neurons || []
            };
        } catch (jsonError) {
            {# Fall back to JS file #}
            try {
                return await this.loadFromJSFallback();
            } catch (jsError) {
                console.error('Failed to load neuron data for quick search');
                return { names: [], neurons: [] };
            }
        }
    }

    loadFromJSFallback() {
        return new Promise((resolve, reject) => {
            window.quickSearchDataCallback = (data) => {
                delete window.quickSearchDataCallback;
                resolve({
                    names: data.names || [],
                    neurons: data.neurons || []
                });
            };

            const script = document.createElement('script');
            script.src = 'data/neurons.js';
            script.async = true;

            script.onload = () => {
                if (window.NEURON_DATA_FALLBACK && window.quickSearchDataCallback) {
                    const data = window.NEURON_DATA_FALLBACK;
                    delete window.NEURON_DATA_FALLBACK;
                    delete window.quickSearchDataCallback;
                    resolve({
                        names: data.names || [],
                        neurons: data.neurons || []
                    });
                }
                setTimeout(() => {
                    if (window.quickSearchDataCallback) {
                        delete window.quickSearchDataCallback;
                        reject(new Error('Callback not invoked'));
                    }
                }, 100);
            };

            script.onerror = () => {
                delete window.quickSearchDataCallback;
                reject(new Error('Failed to load neurons.js'));
            };

            document.head.appendChild(script);
        });
    }

    createDropdown() {
        const dropdown = document.createElement("div");
        dropdown.className = "neuron-search-dropdown";
        dropdown.style.cssText = `
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        `;

        {# Insert dropdown after the input element #}
        const parent = this.inputElement.parentNode;
        parent.style.position = "relative";
        parent.appendChild(dropdown);

        return dropdown;
    }

    setupEventListeners() {
        {# Input event for real-time search #}
        this.inputElement.addEventListener("input", (e) => {
            this.handleInput(e.target.value);
        });

        {# Keyboard navigation #}
        this.inputElement.addEventListener("keydown", (e) => {
            this.handleKeyDown(e);
        });

        {# Focus and blur events #}
        this.inputElement.addEventListener("focus", () => {
            if (this.inputElement.value.trim()) {
                this.showDropdown();
            }
        });

        this.inputElement.addEventListener("blur", () => {
            if (!this.clickingDropdown) {
                setTimeout(() => this.hideDropdown(), 150);
            }
        });

        {# Document click to hide dropdown #}
        document.addEventListener("click", (e) => {
            if (!this.inputElement.contains(e.target) && !this.dropdown.contains(e.target)) {
                this.hideDropdown();
            }
        });
    }

    handleInput(value) {
        const query = value.trim().toLowerCase();

        if (query.length < 2) {
            this.hideDropdown();
            return;
        }

        {# Filter neuron types #}
        this.filteredTypes = this.neuronTypes.filter(type => {
            {# Check main type name #}
            if (type.toLowerCase().includes(query)) {
                return true;
            }

            {# Search in neuron data for synonyms and flywire types #}
            const neuronEntry = this.neuronData.find(entry => entry.name === type);
            if (neuronEntry && neuronEntry.types) {
                {# Search in synonyms #}
                if (neuronEntry.types.synonyms && Array.isArray(neuronEntry.types.synonyms)) {
                    for (const synonym of neuronEntry.types.synonyms) {
                        const synonymLower = synonym.toLowerCase();
                        if (synonymLower.includes(query)) {
                            return true;
                        }
                        {# Also search in just the part after colon (the actual name) #}
                        const colonIndex = synonymLower.indexOf(':');
                        if (colonIndex !== -1) {
                            const nameAfterColon = synonymLower.substring(colonIndex + 1).trim();
                            if (nameAfterColon.includes(query)) {
                                return true;
                            }
                        }
                    }
                }

                {# Search in flywire types #}
                if (neuronEntry.types.flywire && Array.isArray(neuronEntry.types.flywire)) {
                    for (const flywireType of neuronEntry.types.flywire) {
                        if (flywireType.toLowerCase().includes(query)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        });

        {# Sort by relevance (exact matches first, then starts with, then contains) #}
        this.filteredTypes.sort((a, b) => {
            const aLower = a.toLowerCase();
            const bLower = b.toLowerCase();

            {# Exact match comes first #}
            if (aLower === query) return -1;
            if (bLower === query) return 1;

            {# Starts with query comes next #}
            if (aLower.startsWith(query) && !bLower.startsWith(query)) return -1;
            if (bLower.startsWith(query) && !aLower.startsWith(query)) return 1;

            {# Otherwise alphabetical order #}
            return a.localeCompare(b);
        });

        {# Limit results to prevent performance issues #}
        this.filteredTypes = this.filteredTypes.slice(0, 10);

        this.currentIndex = -1;
        this.updateDropdown();
        this.showDropdown();
    }

    handleKeyDown(e) {
        if (!this.isDropdownVisible) {
            return;
        }

        switch (e.key) {
            case "ArrowDown":
                e.preventDefault();
                this.currentIndex = Math.min(this.currentIndex + 1, this.filteredTypes.length - 1);
                this.updateHighlight();
                break;

            case "ArrowUp":
                e.preventDefault();
                this.currentIndex = Math.max(this.currentIndex - 1, -1);
                this.updateHighlight();
                break;

            case "Enter":
                e.preventDefault();
                if (this.currentIndex >= 0 && this.currentIndex < this.filteredTypes.length) {
                    this.selectNeuronType(this.filteredTypes[this.currentIndex]);
                } else if (this.filteredTypes.length > 0) {
                    this.selectNeuronType(this.filteredTypes[0]);
                }
                break;

            case "Escape":
                this.hideDropdown();
                this.inputElement.blur();
                break;
        }
    }

    updateDropdown() {
        this.dropdown.innerHTML = "";

        if (this.filteredTypes.length === 0) {
            const noResults = document.createElement("div");
            noResults.textContent = "No matching neuron types found";
            noResults.style.cssText = `
                padding: 8px 12px;
                color: #666;
                font-style: italic;
            `;
            this.dropdown.appendChild(noResults);
            return;
        }

        this.filteredTypes.forEach((type, index) => {
            const item = document.createElement("div");
            item.className = "neuron-search-item";
            item.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
                transition: background-color 0.2s;
            `;

            {# Create content with neuron name and clickable available sides #}
            const neuronEntry = this.neuronData.find(entry => entry.name === type);

            {# Create neuron name element #}
            const nameSpan = document.createElement('span');
            nameSpan.className = 'neuron-name';
            nameSpan.style.cssText = `
                color: inherit;
                cursor: pointer;
            `;

            {# Highlight matching text in neuron name #}
            const query = this.inputElement.value.trim().toLowerCase();
            if (query) {
                const regex = new RegExp(`(${this.escapeRegExp(query)})`, "gi");
                nameSpan.innerHTML = type.replace(regex, "<strong>$1</strong>");
            } else {
                nameSpan.textContent = type;
            }

            item.appendChild(nameSpan);

            {# Add available sides as clickable links #}
            if (neuronEntry && neuronEntry.urls) {
                const sides = [];
                if (neuronEntry.urls.right) sides.push({ label: 'R', side: 'right' });
                if (neuronEntry.urls.middle) sides.push({ label: 'M', side: 'middle' });
                if (neuronEntry.urls.left) sides.push({ label: 'L', side: 'left' });
                if (neuronEntry.urls.combined && sides.length === 0) sides.push({ label: 'Combined', side: 'combined' });

                if (sides.length > 0) {
                    const sidesContainer = document.createElement('span');
                    sidesContainer.textContent = ' (';
                    sidesContainer.style.color = '#666';

                    sides.forEach((sideInfo, index) => {
                        if (index > 0) {
                            const separator = document.createElement('span');
                            separator.textContent = ', ';
                            separator.style.color = '#666';
                            sidesContainer.appendChild(separator);
                        }

                        const sideLink = document.createElement('a');
                        sideLink.textContent = sideInfo.label;
                        sideLink.href = neuronEntry.urls[sideInfo.side] || '#';
                        sideLink.className = 'side-link';
                        sideLink.style.cssText = `
                            color: #0066cc;
                            text-decoration: none;
                            cursor: pointer;
                            font-size: 0.9em;
                        `;

                        {# Hover effect #}
                        sideLink.addEventListener('mouseenter', () => {
                            sideLink.style.textDecoration = 'underline';
                        });
                        sideLink.addEventListener('mouseleave', () => {
                            sideLink.style.textDecoration = 'none';
                        });

                        {# Handle navigation on mousedown to avoid click event conflicts #}
                        sideLink.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            window.location.href = 'types/' + neuronEntry.urls[sideInfo.side];
                        });

                        {# Keep click handler for backup #}
                        sideLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        });

                        sidesContainer.appendChild(sideLink);
                    });

                    const closeParen = document.createElement('span');
                    closeParen.textContent = ')';
                    closeParen.style.color = '#666';
                    sidesContainer.appendChild(closeParen);

                    item.appendChild(sidesContainer);
                }
            }

            {# Mouse events for click handling #}
            item.addEventListener("mousedown", (e) => {
                {# Only prevent default if not clicking on a side link #}
                if (!e.target.classList.contains('side-link')) {
                    e.preventDefault(); // Prevent input blur
                    this.clickingDropdown = true;
                } else {
                    {# Don't prevent default for side links - let their handler work #}
                    return;
                }
            });

            {# Main item click handler (neuron name goes to primary page, side links handled separately) #}
            item.addEventListener("click", (e) => {
                if (!e.target.classList.contains('side-link')) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.selectNeuronType(type);
                    this.clickingDropdown = false;
                } else {
                    {# Don't prevent default or stop propagation for side links #}
                    return true;
                }
            });

            {# Hover handler #}
            item.addEventListener("mouseenter", () => {
                this.currentIndex = index;
                this.updateHighlight();
            });

            this.dropdown.appendChild(item);
        });
    }

    escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    updateHighlight() {
        const items = this.dropdown.querySelectorAll(".neuron-search-item");
        items.forEach((item, index) => {
            if (index === this.currentIndex) {
                item.style.backgroundColor = "#f0f8ff";
                item.style.color = "#0066cc";
            } else {
                item.style.backgroundColor = "";
                item.style.color = "";
            }
        });
    }

    selectNeuronType(type) {
        {# Close dropdown and update input #}
        this.inputElement.value = type;
        this.hideDropdown();

        {# Navigate to the neuron type page #}
        this.navigateToNeuronType(type);
    }

    navigateToSomaSide(neuronType, side) {
        const neuronEntry = this.neuronData.find(entry => entry.name === neuronType);

        if (neuronEntry && neuronEntry.urls && neuronEntry.urls[side]) {
            {# Close dropdown and update input #}
            this.inputElement.value = neuronType;
            this.hideDropdown();
            {# Navigate to the specific side page - add types/ prefix #}
            window.location.href = 'types/' + neuronEntry.urls[side];
        } else {
            {# Fallback to primary URL #}
            this.navigateToNeuronType(neuronType);
        }
    }

    navigateToNeuronType(neuronType) {
        {# Find the neuron data entry for this type #}
        const neuronEntry = this.neuronData.find(entry => entry.name === neuronType);

        if (neuronEntry && neuronEntry.urls) {
            {# Get primary URL (prefer combined, then left, then right, then middle) #}
            const primaryUrl = neuronEntry.urls.combined ||
                              neuronEntry.urls.left ||
                              neuronEntry.urls.right ||
                              neuronEntry.urls.middle ||
                              `${neuronType}.html`;
            {# Navigate with types/ prefix #}
            window.location.href = 'types/' + primaryUrl;
        } else {
            {# Fallback to the old detection method #}
            this.navigateToNeuronTypeWithDetection(neuronType);
        }
    }

    async navigateToNeuronTypeWithDetection(neuronType) {
        {# Check which file naming convention exists for this neuron type #}
        const possibleFilenames = [
            `types/${neuronType}.html`,
            `types/${neuronType}_B.html`,
            `types/${neuronType}_L.html`,
            `types/${neuronType}_R.html`,
            `types/${neuronType}_M.html`
        ];

        {# Try to find which file exists #}
        for (const filename of possibleFilenames) {
            try {
                const response = await fetch(filename, { method: 'HEAD' });
                if (response.ok) {
                    window.location.href = filename;
                    return;
                }
            } catch (error) {
                {# Continue to next filename #}
            }
        }

        {# If no file found, default to the basic filename #}
        window.location.href = `types/${neuronType}.html`;
    }

    showDropdown() {
        if (this.filteredTypes.length > 0 || this.inputElement.value.trim().length >= 2) {
            this.dropdown.style.display = "block";
            this.isDropdownVisible = true;
        }
    }

    hideDropdown() {
        this.dropdown.style.display = "none";
        this.isDropdownVisible = false;
        this.clickingDropdown = false;
    }
}
</script>

{% endblock %}

{% block footer %}
{% include "sections/footer.html.jinja" %}
{% endblock %}

{% block extra_scripts %}
{% include "sections/global_scripts.html.jinja" %}
{% endblock %}
